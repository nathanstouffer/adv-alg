\documentclass{article}
\usepackage{../fasy-hw}
\usepackage{ wasysym }

%% UPDATE these variables:
\renewcommand{\hwnum}{5}
\title{Advanced Algorithms, Homework \hwnum}
\author{Nathan Stouffer}
\collab{n/a}
\date{due: 15 October 2020}

\begin{document}

\maketitle

\nextprob
\collab{n/a}

You should make at least ten contributions to the Piazza board
discussing the solutions to Problems in Chapter 5 or 6 of the textbook.  Your
contribution does not have to be a complete solution.  It can be any element of
a full solution to a problem requiring an algorithm as an answer.  (For this
question, the outcomes are: insufficient posts (-1), low pass (+1), pass (+3),
and high pass (+5).

Caveat: The number of contributions that can count from a single day are the
number of days before the assignment is due +1.  (So, Thursday the 15th, you can
have one post count, the day before two, etc.)

\paragraph{Answer}

% ============================================

My contributions are:
\begin{enumerate}
    \item (Chapter 6 Question 5 at 12:45 pm on 10/09/2020). \\
        An edge $e$ in a connected undirected graph $G$ is called a bridge (or a cut edge) if the subgraph $G - e $ (obtained by removing $e$ from $G$) is disconnected.
        \begin{enumerate}[label=(\alph*)]
            \item Given $G$ and edge $e$ describe a linear-time algorithm that determines whether $e$ is a bridge or not. What is the running time to find all bridges by trying your algorithm for each edge?
            \item Let $T$ be an arbitrary spanning tree of $G$. Prove that every bridge of $G$ is also an edge in $T$. This claim implies that $G$ has at most $V-1$ bridges. How does this information improve your algorithm from part (a) to find all bridges?
            \item Now suppose we root $T$ at an arbitrary vertex $r$. For any vertex $v$, let $T_v$ denote the subtree of $T$ rooted at $v$; for example, $T_r = T$. Let $uv$ be an arbitrary edge of $T$, where $u$ is the parent of $v$. Prove that $uv$ is a bridge of $G$ if and only if $uv$ is the only edge in $G$ with exactly one endpoint in $T_v$ .
            \item Describe a linear-time algorithm to identify every bridge in $G$. [Hint: Let $T$ be a depth-first spanning tree of $G$.]
        \end{enumerate}
    \item (Chapter 6 Question 5 at 11:00 am on 10/10/2020). \\
        For part a, we are given a graph $G$ and and edge $e$. From there, we must determine if $e$ is a bridge for $G$ in linear time. To do this, we can use the following pseudocode.

        \begin{algorithm}
            IsBridge(G, e) \\
            $\cdot$ \hspace{1em} src = source(e) \\
            $\cdot$ \hspace{1em} trg = target(e) \\
            $\cdot$ \hspace{1em} H = G - e \\
            $\cdot$ \hspace{1em} dfs(H, src) \\
            $\cdot$ \hspace{1em} if (trg is not marked in H): \\
            $\cdot$ \hspace{2em} return True \\
            $\cdot$ \hspace{1em} return False \\
        \end{algorithm}

        Every line in the above algorithm (except for $dfs(H, src)$) runs in constant time. We know that first search runs in $O(V + E)$ time so the $IsBridge()$ runs in linear time. The algorithm is correct because depth first search marks all vertices that are reachable from a source vertex. We are running depth first search on the graph H, which does not contain our query edge $e$. So if we do not mark $trg$ in depth first search, then $H$ (which is $G$ without $e$) is disconnected.

        As far as the running time to find all bridges, we must call $IsBridge$ on each edge in the graph $G$. So the runtime is $EO(V + E) = O(EV + E^2)$.
    \item (Chapter 6 Question 5 at 10:30 pm on 10/12/2020). \\
        I was thinking that a proof by contradiction would fit nicely here.

        Claim: Let $G$ be a connected graph, and let $T$ be an arbitrary spanning tree of $G$.
        Every bridge of $G$ is also an edge in $T$.

        Proof: Let $G = (V, E)$ be a connected graph with spanning tree $T = (V_T, E_T)$.
        Let $e$ be a bridge in $G$.
        Now suppose that $e$ is not in $T$ ($T \subset G - e$).
        Since $T$ is a spanning tree, $T$ contains a path from every $u \in V$ to every $v \in V$.
        But this is a contradiction since $T \subset G - e$ and $G- e$ is disconnected (so some vertices exist with no paths between them).
        Since we reached a contradiction by assuming that $e$ is not in $T$, that must have been an incorrect assumption.
        So it must have been true that $e$ is in $T$.
    \item (Chapter 6 Question 15 at 11:30 pm on 10/12/2020). \\
        A polygonal path is a sequence of line segments joined end-to-end; the endpoints of these line segments are called the vertices of the path.
        The length of a polygonal path is the sum of the lengths of its segments.
        A polygonal path with vertices $(x_1, y_1), (x_2, y_2), ... ,(x_k, y_k)$ is monotonically increasing if $x_i < x_{i+1}$ and $y_i < y_{i+1}$ for every index $i$ --- informally, each vertex of the path is above and to the right of its predecessor.

        Suppose you are given a set $S$ of $n$ points in the plane, represented as two arrays $X[1 .. n]$ and $Y [1 .. n]$.
        Describe and analyze an algorithm to compute the length of the longest monotonically increasing path with vertices in $S$.
        Assume you have a subroutine $L(x, y, x_0, y_0)$ that returns the length of the segment from $(x, y)$ to $(x_0, y_0)$.
    \item (Chapter 6 Question 15 at 10:40 am on 10/12/2020). \\
        The problem already gives some description of input.
        We are given $n$ points in the plane in the form of two arrays: $X[1..n]$ and $Y[1..n]$.
        Suppose we preprocess the input as follows before calling our algorithm.
        The function $SortByX$ sorts the array of $X$ coordinates but preserves the parrallel property of the arrays $X$ and $Y$.

        \begin{algorithm}
            \textsc{LongestPolygonalPath}(X[1..n], Y[1..n]) \\
            $\cdot $ \hspace{1em} X, Y = SortByX(X, Y) \\
            $\cdot $ \hspace{1em} L[1..n] = [ -inf, -inf, ..., -inf ] \\
            $\cdot $ \hspace{1em} return LPP(X, Y, 0)
        \end{algorithm}

        We can implicitly represent the underlying graph with the following rules. Given an $k$, we can draw an edge from the point $(X[k], Y[k])$ to every point $(X[i], Y[i])$ where $i > k$ and $Y[i] \geq Y[k]$. In words, since $X$ is sorted we can't select any point with index less than $k$. Additionally, we need to check that the point we select does not have a lower $Y$ coordinate than our previous point (this would violate monotonically increasing).

        Now that we have established the underlying graph, we can run the following algorithm. In this algorithm, we compute every possible monotonically increasing sequence and return the path with the longest length. Note that $k$ is the index of the most recently added vertex to the path.
        \newpage
        \begin{algorithm}
            \textsc{LLP}(X, Y, k) \\
            $\cdot $ \hspace{1em} x = X[k] \\
            $\cdot $ \hspace{1em} y = Y[k] \\
            $\cdot $ \hspace{1em} max  = 0 \\
            $\cdot $ \hspace{1em} test = 0 \\
            $\cdot $ \hspace{1em} for i in k+1..n // check all possible outgoing edges \\
            $\cdot $ \hspace{1em} if (Y[i] $\geq$ Y[k])	// make sure edge is monotonically increasing in Y \\
            $\cdot $ \hspace{2em} test = L(x, y, X[i], Y[i]) + \textsc{LLP}(X, Y, i) \\
            $\cdot $ \hspace{1em} if  (test $>$ max) \\
            $\cdot $ \hspace{2em} max = test \\
            $\cdot $ \hspace{1em} return max
        \end{algorithm}

        However, this run time is absolutely atrocious. I think this is what happens in the very worst case. The recurrence relation is $T(n) = n * T(O(n-1))$. The $n$ comes from the for loop and the $O(n-1)$ comes from the fact that, in the worst case, only the current point is now ineligible to be a part of the monotonically increasing path. So the run time is $O(n!)$ in the worst case.
    \item (Chapter 6 Question 15 at TODO on 10/12/2020). \\
        We can improve on this run time practically (although I am struggling to think of a theoretical improvement).
        Instead of the preprocessing used above, we should use the following preprocessor function that initializes a global array $L[1..n]$.
        This array stores the longest discovered path (subject to the constraints) to vertex $i$ in $L[i]$.

        \begin{algorithm}
        \textsc{LongestPolygonalPath}(X[1..n], Y[1..n]) \\
            $\cdot$ \hspace{1em} X, Y = SortByX(X, Y) \\
            $\cdot$ \hspace{1em} L[1..n] = [ -inf, -inf, ..., -inf ] \\
            $\cdot$ \hspace{1em} return max(L)
        \end{algorithm}

        Then our algorithm can perform an additional check to see if a longer path to the same vertex has already been discovered.

        \begin{algorithm}
            $\cdot$ \hspace{1em} LLP(X[1..n], Y[1..n], k) \\
            $\cdot$ \hspace{1em} x = X[k] \\
            $\cdot$ \hspace{1em} y = Y[k] \\
            $\cdot$ \hspace{1em} for i in k+1..n \\
            $\cdot$ \hspace{2em} if (Y[i] $\geq$ Y[k]) \\
            $\cdot$ \hspace{3em} if (L[k] + L(x, y, X[i], Y[i]) $>$ L[i]) \\
            $\cdot$ \hspace{4em} L[i] = L[k] + L(x, y, X[i], Y[i]) \\
            $\cdot$ \hspace{4em} LLP(X, Y, i)
        \end{algorithm}

        Practically, this new algorithm will not compute some paths that we know will not be the longest polygonal path because a longer one to the same vertex has already been discovered.
        However, this does not improve the theoretical bound of $O(n!)$.
\end{enumerate}

% ============================================

\nextprob
\collab{n/a}

Chapter 4, Question 1 (Greedy Schedule).  I encourage you to think through all 9
alternative schedules.  However, you only need to hand in two:
\begin{enumerate}
    \item Choose one alternate strategy that
        works, and prove that it works.
    \item Choose one alternate strategy that does not work, and give a
        counter-example.
\end{enumerate}

\paragraph{Answer}
% ============================================

TODO: your answer goes between these lines

% ============================================


\nextprob
\collab{n/a}

Chapter 4, Question 3 (Interval Covering).

This question asks you to come up with an algorithm.  As a reminder, you are
expected to provide:
\begin{enumerate}
    \item Describe the problem in your own words, including
        describing what the input and output is.
    \item Describe, in paragraph form, the algorithm you propose.
    \item Provide a nicely formatted algorithm to solve the problem.
    \item Use a decrementing function to prove that algorithm terminates.
            OR  Give the runtime with justification.
    \item Prove partial correctness.  In other words, if there is a loop or
        recursion, what is the loop/recursion invariant? Provide the proof.
        (Note: you only need to do this for the outer-most loop if there are
        nested loops).
\end{enumerate}



\paragraph{Answer}
% ============================================

TODO: your answer goes between these lines

% ============================================

\nextprob
\collab{n/a}

Suppose someone poses a problem to you, and you have a hunch that it can be
solved with a dynamic program.  Describe, in your own words, the steps you will
take to work through finding a solution to the problem.  If it helps, you can
choose an example to illustrate working through the process.

\paragraph{Answer}

% ============================================

TODO: your answer goes between these lines

% ============================================



\nextprob
\collab{n/a}

Choose one concept or algorithm that you have learned
in this class so far. Describe it to someone who has
taken 232 and 246, but not 432.

\paragraph{Answer}

% ============================================

TODO: your answer goes between these lines

% ============================================

\nextprob
\collab{n/a}

The final course project is to research a ``recent'' algorithm and make a
five-minute video about it.  This semester, I am offering an alternate
assignment: to give complete (polished) solutions to five algorithms (of a
choice of 10).
Please state your preference among the following:

\begin{enumerate}
    \item You would like to do the standard project, and you know who you want
        to work with (let us know here).
    \item You would like to do the standard project, but you would like us to
        assign your group.
    \item You would like to do the alternate assignment instead.
\end{enumerate}

\paragraph{Answer}

% ============================================

TODO: your answer goes between these lines

% ============================================



\end{document}
